#!/bin/bash
set -e
cd "$(dirname "$0")/.."

# Optional test filter - run only tests matching this pattern
# Usage: ./scripts/test_all_browsers [filter]
# Available tests:
#   example_thread_log, example_thread_panic, example_thread_panic_hook
#   example_log, example_panic, example_panic_hook
#   tests/log, tests/panic, tests/thread_log, tests/thread_panic
TEST_FILTER="${1:-}"

should_run_test() {
    local test_name="$1"
    if [ -z "$TEST_FILTER" ]; then
        return 0  # No filter, run all tests
    fi
    if [[ "$test_name" == *"$TEST_FILTER"* ]]; then
        return 0  # Test name contains filter
    fi
    return 1  # Skip this test
}

needs_server() {
    # Server is needed for example_* tests
    should_run_test "example_thread_log" || \
    should_run_test "example_thread_panic" || \
    should_run_test "example_thread_panic_hook" || \
    should_run_test "example_log" || \
    should_run_test "example_panic" || \
    should_run_test "example_panic_hook"
}

TIMEOUT_SEC=${TIMEOUT_SEC:-5}
PORT=1334
URL="http://127.0.0.1:$PORT"
BROWSERS="firefox chromium webkit"

EXPECTED_MESSAGES=(
    "MAIN_DEBUG_2c7f9a"
    "MAIN_INFO_4e8b3d"
    "MAIN_LOG_6a1c5e"
    "MAIN_WARN_8d4f2b"
    "MAIN_ERROR_0f3e7c"
)

SERVER_PID=""

cleanup() {
    if [ -n "$SERVER_PID" ]; then
        kill $SERVER_PID 2>/dev/null || true
        pkill -9 -P $SERVER_PID 2>/dev/null || true
    fi
}
trap cleanup EXIT INT TERM

if needs_server; then
    # Kill any existing process on the port
    if lsof -ti:$PORT > /dev/null 2>&1; then
        echo "Killing existing process on port $PORT..."
        lsof -ti:$PORT | xargs kill -9 2>/dev/null || true
        sleep 1
    fi

    # Start the server
    echo "Starting server..."
    ./scripts/example_log > /dev/null 2>&1 &
    SERVER_PID=$!

    # Wait for server
    for i in $(seq 1 15); do
        if curl -s "$URL" > /dev/null 2>&1; then
            echo "Server is ready!"
            break
        fi
        if [ $i -eq 15 ]; then
            echo "Timeout waiting for server"
            exit 1
        fi
        sleep 1
    done
fi

FAILED=0

if should_run_test "example_thread_log"; then
echo ""
echo "example_thread_log:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

THREAD_EXPECTED_MESSAGES=(
    "THREAD_DEBUG_8f3a2b"
    "THREAD_INFO_9c4d1e"
    "THREAD_LOG_7b2e5f"
    "THREAD_WARN_3a6c8d"
    "THREAD_ERROR_1d9f4a"
)

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_thread_log" 2>&1) || true

    MISSING=0
    DUPLICATE=0
    for MSG in "${THREAD_EXPECTED_MESSAGES[@]}"; do
        COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
        if [ "$COUNT" -eq 0 ]; then
            MISSING=1
            break
        elif [ "$COUNT" -gt 1 ]; then
            DUPLICATE=1
            echo "$DISPLAY_NAME... DUPLICATE: found $COUNT occurrences of $MSG"
        fi
    done

    if [ $MISSING -eq 0 ] && [ $DUPLICATE -eq 0 ]; then
        echo "$DISPLAY_NAME... web_sys::console::* from thread WORKS when run via run_browser"
    elif [ $MISSING -eq 1 ]; then
        echo "$DISPLAY_NAME... web_sys::console::* from thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    else
        echo "$DISPLAY_NAME... web_sys::console::* from thread has DUPLICATE logs when run via run_browser."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test for thread_log
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_thread_log" --omit-browser-logs 2>&1) || true

MISSING=0
DUPLICATE=0
for MSG in "${THREAD_EXPECTED_MESSAGES[@]}"; do
    COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
    if [ "$COUNT" -eq 0 ]; then
        MISSING=1
        break
    elif [ "$COUNT" -gt 1 ]; then
        DUPLICATE=1
        echo "CLI... DUPLICATE: found $COUNT occurrences of $MSG"
    fi
done

if [ $MISSING -eq 0 ] && [ $DUPLICATE -eq 0 ]; then
    echo "CLI... web_sys::console::* from thread WORKS when running from terminal"
elif [ $MISSING -eq 1 ]; then
    echo "CLI... web_sys::console::* from thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
else
    echo "CLI... web_sys::console::* from thread has DUPLICATE logs when running from terminal."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "example_thread_panic"; then
# example_thread_panic tests
echo ""
echo "example_thread_panic:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

EXPECTED_THREAD_PANIC="unreachable"

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_thread_panic" 2>&1) || true

    if echo "$OUTPUT" | grep -iq "$EXPECTED_THREAD_PANIC"; then
        echo "$DISPLAY_NAME... panic from thread WORKS when run via run_browser"
    else
        echo "$DISPLAY_NAME... panic from thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test for thread_panic
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_thread_panic" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -iq "$EXPECTED_THREAD_PANIC"; then
    echo "CLI... panic from thread WORKS when running from terminal"
else
    echo "CLI... panic from thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
fi

echo "  NOTE: Checks for 'unreachable'. Add console_error_panic_hook to get full panic messages:"
echo "    console_error_panic_hook::set_once();"
fi

if should_run_test "example_thread_panic_hook"; then
# example_thread_panic_hook tests
echo ""
echo "example_thread_panic_hook:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

EXPECTED_THREAD_PANIC_HOOK="log_party panic from thread!"

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_thread_panic_hook" 2>&1) || true

    if echo "$OUTPUT" | grep -q "$EXPECTED_THREAD_PANIC_HOOK"; then
        echo "$DISPLAY_NAME... panic with hook from thread WORKS when run via run_browser"
    else
        echo "$DISPLAY_NAME... panic with hook from thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test for thread_panic_hook
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_thread_panic_hook" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -q "$EXPECTED_THREAD_PANIC_HOOK"; then
    echo "CLI... panic with hook from thread WORKS when running from terminal"
else
    echo "CLI... panic with hook from thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "example_log"; then
echo ""
echo "example_log:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_log" 2>&1) || true

    MISSING=0
    DUPLICATE=0
    for MSG in "${EXPECTED_MESSAGES[@]}"; do
        COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
        if [ "$COUNT" -eq 0 ]; then
            MISSING=1
            break
        elif [ "$COUNT" -gt 1 ]; then
            DUPLICATE=1
            echo "$DISPLAY_NAME... DUPLICATE: found $COUNT occurrences of $MSG"
        fi
    done

    if [ $MISSING -eq 0 ] && [ $DUPLICATE -eq 0 ]; then
        echo "$DISPLAY_NAME... web_sys::console::* on the main thread WORKS when run via run_browser"
    elif [ $MISSING -eq 1 ]; then
        echo "$DISPLAY_NAME... web_sys::console::* on the main thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    else
        echo "$DISPLAY_NAME... web_sys::console::* on the main thread has DUPLICATE logs when run via run_browser."
        FAILED=$((FAILED + 1))
    fi
done

# Fourth case: Check if wasm-server-runner forwards console output to CLI
cleanup
sleep 1

OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_log" --omit-browser-logs 2>&1) || true

MISSING=0
DUPLICATE=0
for MSG in "${EXPECTED_MESSAGES[@]}"; do
    COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
    if [ "$COUNT" -eq 0 ]; then
        MISSING=1
        break
    elif [ "$COUNT" -gt 1 ]; then
        DUPLICATE=1
        echo "CLI... DUPLICATE: found $COUNT occurrences of $MSG"
    fi
done

if [ $MISSING -eq 0 ]; then
    echo "CLI... web_sys::console::* on the main thread WORKS when running from terminal"
else
    echo "CLI... web_sys::console::* on the main thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "example_panic"; then
# example_panic tests
echo ""
echo "example_panic:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

EXPECTED_PANIC="unreachable"

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_panic" 2>&1) || true

    if echo "$OUTPUT" | grep -iq "$EXPECTED_PANIC"; then
        echo "$DISPLAY_NAME... panic on the main thread WORKS when run via run_browser"
    else
        echo "$DISPLAY_NAME... panic on the main thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test for panic
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_panic" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -iq "$EXPECTED_PANIC"; then
    echo "CLI... panic on the main thread WORKS when running from terminal"
else
    echo "CLI... panic on the main thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "example_panic_hook"; then
# example_panic_hook tests
echo ""
echo "example_panic_hook:"
echo "  (tests cargo run --example, NOT cargo test; tests wasm-server-runner, NOT wasm-bindgen-test-runner)"

EXPECTED_PANIC_HOOK="log_party panic!"

for BROWSER in $BROWSERS; do
    # Map browser name for display
    case $BROWSER in
        webkit) DISPLAY_NAME="safari" ;;
        *) DISPLAY_NAME="$BROWSER" ;;
    esac

    OUTPUT=$(./scripts/run_browser "$URL" --$BROWSER --timeout $TIMEOUT_SEC --omit-stdio-logs --exec "./scripts/example_panic_hook" 2>&1) || true

    if echo "$OUTPUT" | grep -q "$EXPECTED_PANIC_HOOK"; then
        echo "$DISPLAY_NAME... panic with hook on the main thread WORKS when run via run_browser"
    else
        echo "$DISPLAY_NAME... panic with hook on the main thread does NOT work when run via run_browser. Do NOT do print-style debugging in this configuration."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test for panic_hook
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/example_panic_hook" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -q "$EXPECTED_PANIC_HOOK"; then
    echo "CLI... panic with hook on the main thread WORKS when running from terminal"
else
    echo "CLI... panic with hook on the main thread does NOT work when running from terminal. Do NOT do print-style debugging in this configuration."
    FAILED=$((FAILED + 1))
fi
fi

# Integration tests (cargo test)
# Clean up the wasm-server-runner before running integration tests
cleanup
sleep 1

if should_run_test "tests/log"; then
echo ""
echo "tests/log.rs:"
echo "  (tests cargo test, NOT cargo run --example; tests wasm-bindgen-test-runner, NOT wasm-server-runner)"

for BROWSER in firefox chrome safari; do
    export WASM_BINDGEN_TEST_ONLY_WEB=1
    export WASM_BINDGEN_USE_BROWSER=$BROWSER

    OUTPUT=$(./scripts/test_log 2>&1) || true

    if echo "$OUTPUT" | grep -q "test .* ok"; then
        echo "$BROWSER... cargo test WORKS"
    else
        echo "$BROWSER... cargo test does NOT work."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test - headless mode (Node.js, no browser)
unset WASM_BINDGEN_TEST_ONLY_WEB
unset WASM_BINDGEN_USE_BROWSER

OUTPUT=$(./scripts/test_log 2>&1) || true

if echo "$OUTPUT" | grep -q "test .* ok"; then
    echo "headless... cargo test WORKS"
else
    echo "headless... cargo test does NOT work."
    FAILED=$((FAILED + 1))
fi

# CLI test - via run_browser (checks if output is forwarded to terminal)
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/test_log" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -q "test .* ok"; then
    echo "CLI... cargo test WORKS when running from terminal"
else
    echo "CLI... cargo test does NOT work when running from terminal."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "tests/panic"; then
echo ""
echo "tests/panic.rs:"
echo "  (tests cargo test, NOT cargo run --example; tests wasm-bindgen-test-runner, NOT wasm-server-runner)"
echo "  NOTE: console_error_panic_hook is NOT needed here - wasm-bindgen-test-runner captures panic messages natively."

for BROWSER in firefox chrome safari; do
    export WASM_BINDGEN_TEST_ONLY_WEB=1
    export WASM_BINDGEN_USE_BROWSER=$BROWSER

    OUTPUT=$(./scripts/test_panic 2>&1) || true

    if echo "$OUTPUT" | grep -q "test .* ok"; then
        echo "$BROWSER... cargo test WORKS"
    else
        echo "$BROWSER... cargo test does NOT work."
        FAILED=$((FAILED + 1))
    fi
done

# CLI test - headless mode (Node.js, no browser)
unset WASM_BINDGEN_TEST_ONLY_WEB
unset WASM_BINDGEN_USE_BROWSER

OUTPUT=$(./scripts/test_panic 2>&1) || true

if echo "$OUTPUT" | grep -q "test .* ok"; then
    echo "headless... cargo test WORKS"
else
    echo "headless... cargo test does NOT work."
    FAILED=$((FAILED + 1))
fi

# CLI test - via run_browser (checks if output is forwarded to terminal)
OUTPUT=$(./scripts/run_browser "$URL" --firefox --timeout $TIMEOUT_SEC --exec "./scripts/test_panic" --omit-browser-logs 2>&1) || true

if echo "$OUTPUT" | grep -q "test .* ok"; then
    echo "CLI... cargo test WORKS when running from terminal"
else
    echo "CLI... cargo test does NOT work when running from terminal."
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "tests/thread_log"; then
echo ""
echo "tests/thread_log.rs:"
echo "  (tests cargo test, NOT cargo run --example; tests wasm-bindgen-test-runner, NOT wasm-bindgen-test-runner)"

THREAD_LOG_EXPECTED=(
    "THREAD_DEBUG_8f3a2b"
    "THREAD_INFO_9c4d1e"
    "THREAD_LOG_7b2e5f"
    "THREAD_WARN_3a6c8d"
    "THREAD_ERROR_1d9f4a"
)

for BROWSER in firefox chrome safari; do
    export WASM_BINDGEN_TEST_ONLY_WEB=1
    export WASM_BINDGEN_USE_BROWSER=$BROWSER

    OUTPUT=$(./scripts/test_thread_log -- --nocapture 2>&1) || true

    MISSING=0
    DUPLICATE=0
    for MSG in "${THREAD_LOG_EXPECTED[@]}"; do
        COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
        if [ "$COUNT" -eq 0 ]; then
            MISSING=1
            break
        elif [ "$COUNT" -gt 1 ]; then
            DUPLICATE=1
            echo "$BROWSER... DUPLICATE: found $COUNT occurrences of $MSG"
        fi
    done

    if [ $MISSING -eq 0 ] && [ $DUPLICATE -eq 0 ]; then
        echo "$BROWSER... all 5 console levels captured"
    elif [ $MISSING -eq 1 ]; then
        echo "$BROWSER... NOT all console levels captured (wasm-bindgen-test-runner limitation)"
        FAILED=$((FAILED + 1))
    else
        echo "$BROWSER... DUPLICATE logs detected (wasm-bindgen-test-runner issue)"
        FAILED=$((FAILED + 1))
    fi
done

# CLI test - headless mode (Node.js, no browser)
unset WASM_BINDGEN_TEST_ONLY_WEB
unset WASM_BINDGEN_USE_BROWSER

OUTPUT=$(./scripts/test_thread_log -- --nocapture 2>&1) || true

MISSING=0
DUPLICATE=0
for MSG in "${THREAD_LOG_EXPECTED[@]}"; do
    COUNT=$(echo "$OUTPUT" | grep -c "$MSG" || true)
    if [ "$COUNT" -eq 0 ]; then
        MISSING=1
        break
    elif [ "$COUNT" -gt 1 ]; then
        DUPLICATE=1
        echo "headless... DUPLICATE: found $COUNT occurrences of $MSG"
    fi
done

if [ $MISSING -eq 0 ] && [ $DUPLICATE -eq 0 ]; then
    echo "headless... all 5 console levels captured"
elif [ $MISSING -eq 1 ]; then
    echo "headless... NOT all console levels captured (wasm-bindgen-test-runner limitation)"
    FAILED=$((FAILED + 1))
else
    echo "headless... DUPLICATE logs detected (wasm-bindgen-test-runner issue)"
    FAILED=$((FAILED + 1))
fi
fi

if should_run_test "tests/thread_panic"; then
echo ""
echo "tests/thread_panic.rs:"
echo "  (tests cargo test, NOT cargo run --example; tests wasm-bindgen-test-runner, NOT wasm-server-runner)"

THREAD_PANIC_EXPECTED="log_party panic from thread!"

for BROWSER in firefox chrome safari; do
    export WASM_BINDGEN_TEST_ONLY_WEB=1
    export WASM_BINDGEN_USE_BROWSER=$BROWSER

    OUTPUT=$(./scripts/test_thread_panic 2>&1) || true

    if echo "$OUTPUT" | grep -q "$THREAD_PANIC_EXPECTED"; then
        echo "$BROWSER... thread panic message captured"
    else
        echo "$BROWSER... thread panic message NOT captured (wasm-bindgen-test-runner limitation)"
        FAILED=$((FAILED + 1))
    fi
done

# CLI test - headless mode (Node.js, no browser)
unset WASM_BINDGEN_TEST_ONLY_WEB
unset WASM_BINDGEN_USE_BROWSER

OUTPUT=$(./scripts/test_thread_panic 2>&1) || true

if echo "$OUTPUT" | grep -q "$THREAD_PANIC_EXPECTED"; then
    echo "headless... thread panic message captured"
else
    echo "headless... thread panic message NOT captured (wasm-bindgen-test-runner limitation)"
    FAILED=$((FAILED + 1))
fi
fi

echo ""

if [ $FAILED -gt 0 ]; then
    exit 1
fi
